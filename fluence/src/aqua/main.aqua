aqua Main

import "../../.fluence/aqua-dependencies/node_modules/@fluencelabs/aqua-lib/builtin.aqua"
import "../../.fluence/aqua-dependencies/node_modules/@fluencelabs/aqua-lib/subnet.aqua"
import "../../.fluence/aqua-dependencies/node_modules/@fluencelabs/aqua-ipfs/ipfs.aqua"

import "./types.aqua"
import "./helpers.aqua"
import "./services.aqua"
import "./functions.aqua"

export renderOnDSG, bulkUpload, bulkRender, gatherKubos, test

-- func dns() -> AquaMarineResult:

--     res: *AquaMarineResult
--     publications: *TuDsgPublication
--     publication_cid = "bafyreie5cffczrrnbi6gua6hcxg3oxuqnq6tdto37vqt6rpu3qaq5kkave"

--     workers <- getWorkerInfo()
--     for w <- workers:
--         on w.workerId via w.hostId:
--             ip = "143.176.14.172"
--             publications <- fetchPublication(publication_cid)
--             res <- TuDsgHost.a_record(publications!, ip)
--             -- res <- TuDsgHost.certnginx(publications!)

--     <- res!

-- func restart() -> bool:

--     res: *bool

--     workers <- getWorkerInfo()
--     for w <- workers:
--         on w.workerId via w.hostId:
         
--             res <- TuDsgHost.restart()
--     <- res!

-- func certify() -> AquaMarineResult:

--     res: *AquaMarineResult
--     publications: *TuDsgPublication
--     publication_cid = "bafyreicyzb2h56duhh3xwu7rmf4vgodb6y2u762f3gmmygthyl3nwbtsky"

--     workers <- getWorkerInfo()
--     for w <- workers:
--         on w.workerId via w.hostId:
--             publications <- fetchPublication(publication_cid)
--             res <- TuDsgHost.certify(publications!)
--             -- res <- TuDsgHost.certnginx(publications!)

--     <- res!


func streamToArray(stream: *string) -> []string:
  <- stream


func test() -> string :

    workers <- getWorkers()
    Console.print(workers)

    <- "hi"

    
func gatherKubos() -> Kubos :

    internals: *string
    externals: *string
    
    -- can we have aqua-ipfs locally? 
    -- localKubo = Ipfs.get_external_api_multiaddr()
    -- if localKubo.success == true:
    --     externals <<- localKubo.multiaddr

    -- Console.print(workers)

    for w <- getWorkers():
        on w.workerId via w.hostId:
            res: *IpfsMultiaddrResult
            res <- Ipfs.get_local_api_multiaddr()
            if res!.success == true:
                internals <<- res!.multiaddr
            res_: *IpfsMultiaddrResult
            res_ <- Ipfs.get_external_api_multiaddr() 
            if res_!.success == true:
                externals <<- res_!.multiaddr    

    kubos = Kubos(internals = internals, externals= externals)

    Console.print(kubos)

    <- kubos

func renderOnDSG(tempTask: TuDsgPublishTaskTemp, archive_cid: string) -> *AquaMarineResult:

    results: *AquaMarineResult
    debug: *AquaMarineResult
    queue: *[]TuDsgRenderObject

    -- get encrypted publicationData from chain .... 

    task = fromTempTask(tempTask)

    Console.print(task)

    w = randomDevWorker()
    Console.print(w)
    on w.workerId via w.hostId:

        mappings = dagGetToString(task.author.content_mappings)
        content = TuDsgContent.map(task, mappings)
        TuContentTable.insert(content)
        main = TuDsgContent.pebble(task, content)
        queue <<- main
        for ripple <- main!.template.ripples:
            c = TuContentTable.queryRipple(ripple) 
            queue <- TuDsgContent.ripple(task, ripple, c)

        debug <- extractToPath(archive_cid, "/publication")
        debug <- extractToPath(task.publication.templates, "/templates")
        debug <- extractToPath(task.publication.assets, "/publication/assets")
     
        for ros <- queue:
            for ro <- ros:
              --  collections = TuDsgRenderData.single(archive_cid, task.publication)
            --         results <- TuDsgRenderer.single(ro, kubo.multiaddr)
                    
            -- results <- TuDsgRenderCollect.collect(task.publication.name, kubo.multiaddr)

    Console.print(queue)
    Console.print(debug)

    <- results

func bulkUpload(tasks: []TuDsgPublishTaskTemp) -> bool:

    results: *string

    -- w = randomWorker(0)
    -- on w.workerId via w.hostId:
    --     kubo = Ipfs.get_local_api_multiaddr()
    --     if kubo.success == true:
    --         for tempTask <- tasks:
    --             task = fromTempTask(tempTask)
    --             results <- TuDsgContent.map(task, kubo.multiaddr)
    -- Console.print(results)

    <- true

func bulkRender(publication_cid: string, post_type: string, archive_cid: string) -> *AquaMarineResult:

    results: *AquaMarineResult

    publication = fetchPublication(publication_cid)

    Console.print(publication)

    w = randomDevWorker()
    on w.workerId via w.hostId:
        queue: *[]TuDsgRenderObject
        kubo = Ipfs.get_local_api_multiaddr()
        if kubo.success == true:
            queue <- TuDsgContent.bulk(publication, post_type, kubo.multiaddr)
            debug <- TuDsgRenderer.imports(archive_cid, publication, kubo.multiaddr)
            for ros <- queue:
                for ro <- ros:
                    results <- TuDsgRenderer.single(ro, kubo.multiaddr)
                    Peer.timeout(10,"buffering not to overload tableland")
            results <- TuDsgRenderer.collect(publication.name, kubo.multiaddr)


    <- results


 