aqua Main

import "@fluencelabs/aqua-lib/builtin.aqua"
import "@fluencelabs/aqua-lib/subnet.aqua"
import "@fluencelabs/aqua-ipfs/ipfs.aqua"

import "./types.aqua"
import "./helpers.aqua"
import "./services.aqua"

export renderOnDSG, bulkUpload, bulkRender, gatherKubos, helloWorldRemote   --  restart, certify, dns, ,  main -- ,updatePublication

-- local
func helloWorld(name: string) -> string:
    <- Op.concat_strings("Hello, ", name)

-- remote
func helloWorldRemote(name: string) -> string:
    on HOST_PEER_ID:
        hello_msg <- helloWorld(name)
        from_msg <- Op.concat_strings(hello_msg, "! From ")
        from_peer_msg <- Op.concat_strings(from_msg, HOST_PEER_ID)
    <- from_peer_msg

-- func dns() -> AquaMarineResult:

--     res: *AquaMarineResult
--     publications: *TuDsgPublication
--     publication_cid = "bafyreie5cffczrrnbi6gua6hcxg3oxuqnq6tdto37vqt6rpu3qaq5kkave"

--     workers <- getWorkerInfo()
--     for w <- workers:
--         on w.workerId via w.hostId:
--             ip = "143.176.14.172"
--             publications <- fetchPublication(publication_cid)
--             res <- TuDsgHost.a_record(publications!, ip)
--             -- res <- TuDsgHost.certnginx(publications!)

--     <- res!

-- func restart() -> bool:

--     res: *bool

--     workers <- getWorkerInfo()
--     for w <- workers:
--         on w.workerId via w.hostId:
         
--             res <- TuDsgHost.restart()
--     <- res!

-- func certify() -> AquaMarineResult:

--     res: *AquaMarineResult
--     publications: *TuDsgPublication
--     publication_cid = "bafyreicyzb2h56duhh3xwu7rmf4vgodb6y2u762f3gmmygthyl3nwbtsky"

--     workers <- getWorkerInfo()
--     for w <- workers:
--         on w.workerId via w.hostId:
--             publications <- fetchPublication(publication_cid)
--             res <- TuDsgHost.certify(publications!)
--             -- res <- TuDsgHost.certnginx(publications!)

--     <- res!


func streamToArray(stream: *string) -> []string:
  <- stream
    
func gatherKubos() -> Kubos :

    internals: *string
    externals: *string
    
    -- can we have aqua-ipfs locally? 
    -- localKubo = Ipfs.get_external_api_multiaddr()
    -- if localKubo.success == true:
    --     externals <<- localKubo.multiaddr

    workers <- getWorkerInfo()

    Console.print(workers)

    for w <- workers:
        on w.workerId via w.hostId:
            res: *IpfsMultiaddrResult
            res <- Ipfs.get_local_api_multiaddr()
            if res!.success == true:
                internals <<- res!.multiaddr
            res_: *IpfsMultiaddrResult
            res_ <- Ipfs.get_external_api_multiaddr() 
            if res_!.success == true:
                externals <<- res_!.multiaddr    

    kubos = Kubos(internals = internals, externals= externals)

    <- kubos

func renderOnDSG(tempTask: TuDsgPublishTaskTemp, archive_cid: string) -> *AquaMarineResult:

    results: *AquaMarineResult
    debug: *AquaMarineResult

    -- get encrypted publicationData from chain .... 

    task = fromTempTask(tempTask)

    -- Console.print(task)

    w = randomWorker()
    on w.workerId via w.hostId:
        queue: *[]TuDsgRenderObject
        kubo = Ipfs.get_local_api_multiaddr()
        if kubo.success == true:
            cid = TuDsgContent.persist_single(task, kubo.multiaddr)
            queue <- TuDsgContent.create_render_objects(task, cid, kubo.multiaddr)
            -- results <- TuDsgRenderUndressed.test()
            debug <- TuDsgRenderer.imports(archive_cid, task.publication, kubo.multiaddr)
            for ros <- queue:
                for ro <- ros:
                    results <- TuDsgRenderer.single(ro, kubo.multiaddr)
                    
            results <- TuDsgRenderer.collect(task.publication.name, kubo.multiaddr)

    Console.print(debug)

    <- results

func bulkUpload(tasks: []TuDsgPublishTaskTemp) -> bool:

    results: *string

    w = randomWorker()
    on w.workerId via w.hostId:
        kubo = Ipfs.get_local_api_multiaddr()
        if kubo.success == true:
            for tempTask <- tasks:
                task = fromTempTask(tempTask)
                results <- TuDsgContent.persist_single(task, kubo.multiaddr)


    Console.print(results)

    <- true

func bulkRender(publication_cid: string, post_type: string, archive_cid: string) -> *AquaMarineResult:

    results: *AquaMarineResult

    publication = fetchPublication(publication_cid)

    Console.print(publication)

    w = randomWorker()
    on w.workerId via w.hostId:
        queue: *[]TuDsgRenderObject
        kubo = Ipfs.get_local_api_multiaddr()
        if kubo.success == true:
            queue <- TuDsgContent.bulk(publication, post_type, kubo.multiaddr)
            debug <- TuDsgRenderer.imports(archive_cid, publication, kubo.multiaddr)
            for ros <- queue:
                for ro <- ros:
                    results <- TuDsgRenderer.single(ro, kubo.multiaddr)
                    Peer.timeout(10,"buffering not to overload tableland")
            results <- TuDsgRenderer.collect(publication.name, kubo.multiaddr)


    <- results


 