export const JSON_NPUBLICATION = {
    "language": "Solidity",
    "sources": {
        "@openzeppelin/contracts/utils/Create2.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(\n        uint256 amount,\n        bytes32 salt,\n        bytes memory bytecode\n    ) internal returns (address) {\n        address addr;\n        require(address(this).balance >= amount, \"Create2: insufficient balance\");\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n        return addr;\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(\n        bytes32 salt,\n        bytes32 bytecodeHash,\n        address deployer\n    ) internal pure returns (address) {\n        bytes32 _data = keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash));\n        return address(uint160(uint256(_data)));\n    }\n}\n"
        },
        "contracts/NPublication.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.24;\n\n// import \"@account-abstraction/contracts/core/EntryPoint.sol\";\n// import \"@account-abstraction/contracts/interfaces/IAccount.sol\";\n// import \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\n\ncontract NPublication  {   \n\n    address public owner;\n    string public config;\n    string public html_root;\n    address[] public whitelisted_authors;      \n    \n    event NOffer(address indexed author, address indexed publication, string indexed content);\n    event NRootUpdate(string html_root);\n    event NConfigUpdate(string config);\n\n    constructor(address _initiator, string memory _config, string memory _html_root) {\n        config = _config;\n        html_root = _html_root;\n        owner = _initiator;\n    }\n\n    function _inArray(address[] memory _array, address _address) private pure returns (bool) {\n        \n        for (uint i = 0; i < _array.length; i++) {\n            if (_array[i] == _address) {\n                return true;\n            } \n        }\n        \n        return false;\n    }\n\n    function acceptOffer(address author, address publication, string calldata content_cid) external returns (bool) {\n\n        emit NOffer(msg.sender, publication, content_cid);\n\n        if (_inArray(whitelisted_authors, author)) {\n            return true;\n        } else {\n            return false;\n        }\n    }  \n\n    function changeOwner(address new_owner) external {\n\n        if(msg.sender == owner) {\n            owner = new_owner;\n        }\n    }\n\n    function whitelist(address author) external {\n\n        if(msg.sender == owner) {\n            whitelisted_authors.push(author);\n        }\n    }\n\n    function updateConfig(string calldata _config) external {\n\n        if(msg.sender == owner) {\n            config = _config;\n            emit NConfigUpdate(config);\n        }\n    }\n\n    function updateHtmlRoot(string calldata _html_root) external {\n        \n        // how do we protect this ??? \n        // fixed address for printer ?? \n        // has signature by auth &&|| publication owner ??? \n        html_root = _html_root;\n        emit NRootUpdate(html_root);\n    }\n\n} \n\ncontract NPublicationFactory {\n\n    // is being used as dummy call in contract creation!\n    function test() pure external returns (string memory) {\n        return \"hello\";\n    }\n\n    function concatBytes16(address owner, string memory cid) public pure returns (bytes32 result) {\n            bytes memory _cid = bytes(cid);\n            bytes16 o = bytes16(bytes20(owner)); \n            bytes16 c = bytes16(_cid); \n        \n        assembly {\n            // Shift the first 16 bytes (a) to the left by 128 bits (16 bytes)\n            // and then OR it with the second 16 bytes (b)\n            result := or(shl(128, o), c)\n        }\n    }\n\n    function createPublication(address owner, string memory config, string memory html_root) external returns (address) {\n\n        bytes32 salt = concatBytes16(owner, config); // replace cid with name ? \n        bytes memory bytecode = abi.encodePacked(type(NPublication).creationCode, abi.encode(owner, config, html_root));\n\n        address addr = Create2.computeAddress(salt, keccak256(bytecode));\n        uint256 codeSize = addr.code.length;\n        if (codeSize > 0) {\n            return addr;\n        }\n        return deploy(salt, bytecode);\n    }\n\n    function deploy(bytes32 salt, bytes memory bytecode) internal returns (address addr) {\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n    }\n}\n"
        }
    },
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 1000
        },
        "evmVersion": "paris",
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers",
                    "metadata"
                ],
                "": [
                    "ast"
                ]
            }
        }
    }
}